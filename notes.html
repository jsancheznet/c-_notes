<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-06-04 Sat 15:49 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/bigblow.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/bigblow_theme/css/hideshow.css"/>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-1.11.0.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery-ui-1.10.2.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.localscroll-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.scrollTo-1.4.3.1-min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/jquery.zclip.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/bigblow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/bigblow_theme/js/hideshow.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org59c991d">1. Section 1 - Start Here</a></li>
<li><a href="#org5ac8d87">2. Section 2 - Basic Language Facilities</a>
<ul>
<li><a href="#orgc436ce6">2.1. &lt;climits&gt; &amp; &lt;limits.h&gt;</a></li>
<li><a href="#orgb1cd0dc">2.2. &lt;cfloat&gt; &amp; &lt;float.h&gt;</a></li>
<li><a href="#org98b5292">2.3. Input/Output streams</a></li>
<li><a href="#org26d05b8">2.4. Uniform initialization</a></li>
<li><a href="#org55e3b09">2.5. nullptr</a></li>
<li><a href="#orgf7a81bf">2.6. References</a></li>
<li><a href="#orgc1b9f41">2.7. const</a></li>
<li><a href="#orge35eaf4">2.8. std::begin() &amp; std::end() - for range loops</a></li>
<li><a href="#orga6d4f52">2.9. for range loops with custom classes</a></li>
<li><a href="#org724f23f">2.10. Namespaces</a></li>
</ul>
</li>
<li><a href="#org1fd0f67">3. Section 4 - Classes and Objects</a>
<ul>
<li><a href="#org3ad685b">3.1. Basic principles that help us write OO programs</a></li>
<li><a href="#org71749b8">3.2. this pointer</a></li>
<li><a href="#org0897ace">3.3. Static class members</a></li>
<li><a href="#orgcd3f4c5">3.4. const/constant member functions</a></li>
<li><a href="#orgabd502d">3.5. Copy constructors</a>
<ul>
<li><a href="#orge0029e8">3.5.1. How to tell if a class needs a custom copy constructor</a></li>
</ul>
</li>
<li><a href="#org23cdc4d">3.6. Delegating constructor</a></li>
<li><a href="#org7232865">3.7. default and delete functions</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
These are my notes from the Udemy course Complete Modern C++ (C++11/14/17)
</p>


<p>
Notas de cosas a repasar!
</p>

<div id="outline-container-org59c991d" class="outline-2">
<h2 id="org59c991d"><span class="section-number-2">1</span> Section 1 - Start Here</h2>
<div class="outline-text-2" id="text-1">
<p>
No notes, this section covers installing a compiler
</p>
</div>
</div>

<div id="outline-container-org5ac8d87" class="outline-2">
<h2 id="org5ac8d87"><span class="section-number-2">2</span> Section 2 - Basic Language Facilities</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgc436ce6" class="outline-3">
<h3 id="orgc436ce6"><span class="section-number-3">2.1</span> &lt;climits&gt; &amp; &lt;limits.h&gt;</h3>
<div class="outline-text-3" id="text-2-1">
<p>
climits &amp; limits.h provide macros that represent the minimum and maximum values of a type
</p>

<p>
Example:
</p>

<div class="org-src-container">
<pre class="src src-C++">#define CHAR_BIT 8 // Number of bits in char

#define INT_MIN (-2147483647 -1) // Minimum signed int value
#define INT_MAX 2147483647 // Maximum int value
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb1cd0dc" class="outline-3">
<h3 id="orgb1cd0dc"><span class="section-number-3">2.2</span> &lt;cfloat&gt; &amp; &lt;float.h&gt;</h3>
<div class="outline-text-3" id="text-2-2">
<p>
This files hold macros for floats &amp; doubles range limits, Epsilon and more.
</p>
</div>
</div>

<div id="outline-container-org98b5292" class="outline-3">
<h3 id="org98b5292"><span class="section-number-3">2.3</span> Input/Output streams</h3>
<div class="outline-text-3" id="text-2-3">
<p>
#include &lt;iostream&gt;
</p>

<p>
C++ provides 2 classes for input and output
</p>

<p>
std::ostream is for output
std::istream is for input
</p>

<p>
std::cout is an object of the ostream class
std::cin is an object of the istream class
</p>


<p>
std::cin stops reading from keyboard when it encounters a whitespace
character, in order to read a whole line we need to use
std::cin.getline()
</p>
</div>
</div>

<div id="outline-container-org26d05b8" class="outline-3">
<h3 id="org26d05b8"><span class="section-number-3">2.4</span> Uniform initialization</h3>
<div class="outline-text-3" id="text-2-4">
<p>
Uniform initialization is a feature in C++ 11 that allows the usage of
a consistent syntax to initialize variables and objects ranging from
primitive type to aggregates. In other words, it introduces
brace-initialization that uses braces ({}) to enclose initializer
values.
</p>

<div class="org-src-container">
<pre class="src src-C++">int i{};     // initialized built-in type, equals to int i{0};

int j{10}; // initialized built-in type

int a[]{1, 2, 3, 4} // Aggregate initialization

X x1{}; // default constructor

X x2{1}; // Parameterized constructor;

X x4{x3}; // copy-constructor
</pre>
</div>
</div>
</div>

<div id="outline-container-org55e3b09" class="outline-3">
<h3 id="org55e3b09"><span class="section-number-3">2.5</span> nullptr</h3>
<div class="outline-text-3" id="text-2-5">
<p>
Always use nullptr instead of NULL to initialize pointers
</p>

<p>
NULL is a “manifest constant” (a #define of C) that’s actually an integer that can be assigned to a pointer because of an implicit conversion.
</p>

<p>
nullptr is a keyword representing a value of self-defined type, that can convert into a pointer, but not into integers.
</p>

<div class="org-src-container">
<pre class="src src-C++">int i = NULL; // OK
int i = nullptr; // error - not a integer convertible value
int* p = NULL; //ok - int converted into pointer
int* p = nullptr; // ok
That, is important to solve an ambiguity that can arise in generic programming:
</pre>
</div>

<p>
suppose you have two functions in overload:
</p>

<div class="org-src-container">
<pre class="src src-C++">void func(int x);
void func(int* x);
</pre>
</div>

<p>
Now, if you call func(NULL), you are actually calling … the 1) variant, being NULL an int. But func(nullptr) will call the 2) variant, being nullptr not an int.
</p>

<p>
To avoid the risk to call one function instead of another, always use 0 if you want an integer, and nullptr if you want a pointer.
</p>
</div>
</div>
<div id="outline-container-orgf7a81bf" class="outline-3">
<h3 id="orgf7a81bf"><span class="section-number-3">2.6</span> References</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Estudiar references, saberse las diferencias con un puntero!
</p>
</div>
</div>
<div id="outline-container-orgc1b9f41" class="outline-3">
<h3 id="orgc1b9f41"><span class="section-number-3">2.7</span> const</h3>
<div class="outline-text-3" id="text-2-7">
<p>
Repasar const, anotar que es y las varias formas que puede ser usado
</p>

<p>
Se puede intentar leer desde la derecha hacia la izquierda
</p>
</div>
</div>
<div id="outline-container-orge35eaf4" class="outline-3">
<h3 id="orge35eaf4"><span class="section-number-3">2.8</span> std::begin() &amp; std::end() - for range loops</h3>
<div class="outline-text-3" id="text-2-8">
<div class="org-src-container">
<pre class="src src-C++">int Array[] = {1, 2, 3, 4, 5};

// begin and end are usually member functions of containers, but there are also function versions
int *Begin = std::begin(Array);
int *End = std::end(Array);

// std::begin() &amp; std::end() are used to implement for ranged loops using pointer arithmetic

</pre>
</div>
</div>
</div>
<div id="outline-container-orga6d4f52" class="outline-3">
<h3 id="orga6d4f52"><span class="section-number-3">2.9</span> for range loops with custom classes</h3>
<div class="outline-text-3" id="text-2-9">
<p>
If you want to use range based for loops with your custom classes you need to provide iterators for the class
</p>
</div>
</div>
<div id="outline-container-org724f23f" class="outline-3">
<h3 id="org724f23f"><span class="section-number-3">2.10</span> Namespaces</h3>
<div class="outline-text-3" id="text-2-10">
<p>
Using an anonimous namespace will make all the functions, classes,
data visible only on the same .cpp file, similar to static
</p>

<div class="org-src-container">
<pre class="src src-C++">namespace
{
int ThisFunction();
}
</pre>
</div>

<p>
// This function is only visible on the same .cpp file as the anonymous namespace is implemented/declared.
</p>
</div>
</div>
</div>
<div id="outline-container-org1fd0f67" class="outline-2">
<h2 id="org1fd0f67"><span class="section-number-2">3</span> Section 4 - Classes and Objects</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org3ad685b" class="outline-3">
<h3 id="org3ad685b"><span class="section-number-3">3.1</span> Basic principles that help us write OO programs</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>Abstraction</li>
<li>Encapsulation</li>
<li>Inheritance</li>
<li>Polymorphism</li>
</ul>
</div>
</div>
<div id="outline-container-org71749b8" class="outline-3">
<h3 id="org71749b8"><span class="section-number-3">3.2</span> this pointer</h3>
<div class="outline-text-3" id="text-3-2">
<p>
It's a hidden pointer that's passed to every member function
</p>

<p>
Points to the object that invoked the member function
</p>
</div>
</div>

<div id="outline-container-org0897ace" class="outline-3">
<h3 id="org0897ace"><span class="section-number-3">3.3</span> Static class members</h3>
<div class="outline-text-3" id="text-3-3">
<p>
static variables
</p>
<ul class="org-ul">
<li>use static as a qualifier for the variable, ex: static int Integer;</li>
<li>Static variables are not part of the object, they belong to the class.</li>
<li>Only one copy exists across all objects of the same class.</li>
<li>They cannot be initialized inside the class</li>
<li>They have to be defined outside the class for initialization</li>
<li>The compiler by default assigns 0 as a default value</li>
</ul>

<div class="org-src-container">
<pre class="src src-C+++">class car
{
private:
    static int ExampleVariable;
};

// In the class .cpp file initialize the static variable like this:
int car::ExampleVariable = 10; // If nothing is assigned, the compiler defaults the variable to 0
</pre>
</div>

<p>
static functions
</p>

<p>
If we dont have any objects but we still need to access the static variable, we can create static member functions.
</p>

<ul class="org-ul">
<li>assign the static qualifier to a function</li>
<li>The also belong to a class and not objects</li>
<li>They do not recieve the this pointer</li>
<li>They cannot access non-static members of the class since it does not recieve the this pointer</li>
<li>They can be invoked directly through the class name</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">class car
{
    static void ExampleFunction();
};

// in car.cpp

void car::ExampleFunction()
{
    // Do something
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcd3f4c5" class="outline-3">
<h3 id="orgcd3f4c5"><span class="section-number-3">3.4</span> const/constant member functions</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>const member functions cannot change the value of any member variable</li>
<li>they are qualified with the const keyword</li>
<li>Declaration and definition are qualified</li>
<li>useful for creating read-only functions</li>
<li>const objects can invoke only const member functions</li>
<li>we should add const to member functions that do not change the object's state</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">const Car HondaFit; // Honda Fit can only invoke const member functions

class Car
{
    // const is added to the end of the statement, it also needs to be added in function definition
    void ConstantMemberFunction() const;

};

// Car.cpp

void Car::ConstantMemberFunction() const
{
    // Do something
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgabd502d" class="outline-3">
<h3 id="orgabd502d"><span class="section-number-3">3.5</span> Copy constructors</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>A copy constructor creates a copy of the object's state into another object</li>
<li>If no copy constructor is explicitdly defined, C++ creates one that simply copies values.</li>
<li>Custom copy constructors might be needed when the class has pointer
members and the two objects should not hold the same ptr.</li>
<li>Default pointer member variables may crash the application while
creating a shallow copy of the member pointers, that's one reason we
may need custom copy constructors</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">class Integer
{
    int *m_pInt;
public:
    Integer();
    Integer(int Value);
    int GetValue() const;
    void SetValue(int Value);
    ~Integer();
};

Integer::Integer()
{
    m_pInt = new int(0);
}

Integer::Integer(int Value)
{
    m_pInt = new int(Value);
}

int Integer::GetValue() const
{
    return *m_pInt;
}

void Integer::SetValue(int Value)
{
    *m_pInt = Value;
}

Integer::~Integer()
{
    delete m_pInt;
}

// NOTE: This function creates a copy constructor because the object parameter is passed by value
void Print(Integer i)
{
    std::cout &lt;&lt; i &lt;&lt; std::endl;
}

// NOTE: This function makes C++ create a copy constructor because it returns by value
Integer Add(int x, int y)
{
    return Integer(x + y);
}

int main()
{

    Integer i(5);
    Integer i2(i); // This causes C++ to generate a default copy constructor for our class

    i2 = i; // This also invokes a copy constructor
    std::cout &lt;&lt; i.GetValue() &lt;&lt; std::endl;

    return 0;
}

</pre>
</div>

<div class="org-src-container">
<pre class="src src-C++">// How to create a custom copy constructor

class Integer
{
    int *m_pInt;
public:
    // This is how we declare a copy constructor, it MUST pass object by reference
    Integer(Integer &amp;Obj);
};

Integer::Integer(Integer &amp;Obj)
{
    // The following is called a "Deep Copy" of a pointer. A shallow copy just copies the address.
    m_pInt = new int;
    *m_pInt = Obj.m_pInt;

}

</pre>
</div>
</div>

<div id="outline-container-orge0029e8" class="outline-4">
<h4 id="orge0029e8"><span class="section-number-4">3.5.1</span> How to tell if a class needs a custom copy constructor</h4>
<div class="outline-text-4" id="text-3-5-1">
</div>
<ol class="org-ol">
<li><a id="org1442cdc"></a>The rule of 3<br />
<div class="outline-text-5" id="text-3-5-1-1">
<p>
The Rule of Three states that if a type ever needs to have a
user-defined copy constructor, copy assignment operator, or
destructor, then it must have all three.
</p>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-org23cdc4d" class="outline-3">
<h3 id="org23cdc4d"><span class="section-number-3">3.6</span> Delegating constructor</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Delegating constructor are constructors that call other constructors.
</p>

<p>
Suppose we have a few constructors that contain repeated code. That
may become a source of bugs, so the idea is to create a single
constructor that does the shared code and call that constructor from
the other constructors.
</p>

<div class="org-src-container">
<pre class="src src-C++">
class Car
{
public:
    Car::Car();
    Car::Car(float Fuel);
    Car::Car(float Fuel, int Passengers);
private:
    int Passengers;
    float Amount;
};

Car::Car : Car(0) // The default constructor invokes the constructor
		  // with 1 parameter, the constructor invoked runs
		  // first. In this case the constructor with the 2
		  // parameters is the one that gets executed first
{

}

Car::Car(float amount) : Car(amount, 0) // The constructor with 1
					// parameter invokes the
					// constructor with 2
					// parameters
{
}

Car::Car(float amount, int passengers) // This constructor holds the
				       // shared code between
				       // constructors. Now it lives
				       // in only one place
{
    Amount = amount;
    Passengers = passengers;
}


</pre>
</div>
</div>
</div>

<div id="outline-container-org7232865" class="outline-3">
<h3 id="org7232865"><span class="section-number-3">3.7</span> default and delete functions</h3>
<div class="outline-text-3" id="text-3-7">
<p>
In C++11 you can request the compiler to create default implementation
of constructor by using the default keyword.
</p>

<p>
You can only use the default keyword with those functions that can be created by the compiler.
</p>
<ul class="org-ul">
<li>Constructors</li>
<li>Copy Constructors</li>
<li>= operator</li>
</ul>

<div class="org-src-container">
<pre class="src src-C++">
class Integer
{
    int m_Value{0};
public:
    Integer() = default; // This request the compiler to create a default constructor
    Integer(const Integer &amp;Object) = default; // Request the compiler to generate a default copy constructor
};

</pre>
</div>

<p>
the delete keyword is used to tell the compiler not to generate
functions.
</p>

<div class="org-src-container">
<pre class="src src-C++">
class Integer
{
    int m_Value{0};
public:
    Integer(const Integer &amp;Object) = delete; // This request the compiler to not generate a copy constructor.
};

void main()
{
    Integer i1;
    Integer i2(i1); // This will not compile since we prohibited a copy constructor to be used.
}

</pre>
</div>

<p>
Unlike default, delete can be used in any kind of function.
</p>
<div class="org-src-container">
<pre class="src src-C++">
void Test(int Input)
{
    cout &lt;&lt; Input;
}

void Test(float Input) = delete;


void main()
{
int A = 1;
float B = 10.0f;
Test(B); // Without using the keyword delete, The parameter would be
	 // converted to int and the int function called. Now this is a
	 // compile time error.
}

</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2022-06-04 Sat 15:49</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
